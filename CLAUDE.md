# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## 一般的な開発ガイドライン

### 日本語と英語の使い分け
- ユーザーとのやり取り（説明、質問への回答など）: 日本語
- Claude Code 上での分析結果、計画、進捗報告: 日本語
- プランモードでの計画案: 日本語
- エラーメッセージの説明、デバッグ情報: 日本語
- TodoWriteツールのチェックリスト項目: 日本語
- コードのコメント: 英語
- コミットメッセージ: 英語
- PRタイトル・本文: 英語
- ドキュメント（README等）: 英語

### READMEの多言語対応ルール
- **見出しはすべて英語で統一**: README.md、README.ja.md、README.zh-CN.mdすべてのファイルで、セクション見出し（##で始まる部分）は英語表記とする
- **目的**: URLのアンカーリンク（#installation など）を言語間で統一し、リンクの互換性を保つ
- **例**:
  - ✅ `## Installation` （すべての言語版で統一）
  - ❌ `## インストール` （日本語版でも使わない）
  - ❌ `## 安装` （中国語版でも使わない）

### コードの品質
- **型安全性**: TypeScriptの型安全を最優先
- **コードの可読性**: コメントやドキュメントを充実させる
- **テストの充実**: ユニットテスト、統合テストを必ず実装
- **エラー修正時のコメント**: エラーが発生した箇所や修正が必要だった箇所には、なぜそのエラーが起きたのか、どう修正したのかを説明するコメントを積極的に残す

### 実装方針
- **仕様の確認**: 実装前に必ずREADMEを熟読し、プロジェクトの仕様を理解する
- **YAGNI原則**: "You Aren't Gonna Need It" - 将来使うかもしれない機能や関数は作らない
- **未使用コードの防止**: 実際に使用されるコードのみを実装し、未使用の関数やクラスは作成しない
- **リファクタリング**: 綺麗なアーキテクチャを採用し、不要なコードは積極的に削除
- **CI実行**: 実装後は必ず `bun run ci` でコード品質を確認する

### アーキテクチャ方針
- **依存性逆転の原則（DIP）**: すべての具体的なクラスはインターフェースを通じて依存関係を管理する
  - ドメイン層はインターフェースのみを定義（`src/domain/interfaces/`）
  - 具体的な実装はすべてインフラストラクチャ層に配置（`src/infrastructure/`）
  - 上位レイヤーは下位レイヤーの抽象（インターフェース）に依存
- **明示的な依存関係管理**: すべてのクラスの依存関係を`ProcessorDependencies`で宣言
  - 依存関係の完全な可視化
  - テスタビリティの向上（モック注入が容易）
  - 新しいクラスを追加する際は必ずインターフェースを定義し、dependenciesに追加
- **依存性注入パターン**: `processor-factory.ts`で全依存関係を組み立て
  - 各クラスは必要な依存をコンストラクタで受け取る
  - クラス内部で他のクラスをnewしない（ユーティリティ関数を除く）
  - 設定に基づいて適切な実装を選択・注入

### テストの方針
- **カバレッジより意味のあるテスト**: カバレッジ率を追求するのではなく、本当に価値のあるテストのみを実装
  - 100%カバレッジは目標ではない
  - 無意味なテスト（getter/setterのテスト、定数のテストなど）は書かない
  - 重要な振る舞いと境界値に焦点を当てる
- **テストランナー**: テストコードはbunで動作するように実装する（`bun test`コマンドで実行）
- **統合テスト優先**: リファクタリングを頻繁に行うため、内部実装に依存しない統合テストを優先
- **ユニットテストの削減**: 統合テストでカバーされている機能のユニットテストは積極的に削除
- **無駄なテストの例**:
  - 単純なgetter/setterのテスト
  - 型定義や定数の値を確認するだけのテスト
  - フレームワークの機能を再テストするようなテスト
  - 実装の詳細に依存しすぎているテスト
- **テスト失敗時の対応**: テストが失敗した場合、まずそのテスト自体の価値を検討する
  - そのテストは本当に必要か？
  - 統合テストでカバーできないか？
  - テストの削除も重要な選択肢として検討する
- **内部実装への依存を避ける**: 
  - 内部実装の詳細をテストしない（プライベートメソッド、内部状態など）
  - リファクタリング時に修正が必要なテストは作らない
  - 振る舞い（入力と出力）のみをテストする
- **モックの使用を避ける**: 可能な限り実際の実装を使用し、環境差異を生まないテストを書く
  - 外部API呼び出しなど、真にモックが必要な場合のみ使用
  - ユーティリティ関数（logger等）は実際の実装を使用し、オプション（quiet等）で制御
- **エッジケースに集中**: ユニットテストは統合テストでカバーしにくいエラーケースやエッジケースのみ
- **環境依存テストの削除**: パーミッションエラーなど環境に依存するテストは避ける
- **実装の見直し**: テストが複雑になる場合は、まず実装をシンプルにできないか検討する

### TypeScript実装前の型安全確認
- **必ず最初に**: tsconfig.json の型安全制御設定を確認
- **型安全性は最高レベル**: `strict: true`により`noImplicitAny`を含むすべての厳格な型チェックが有効
- **よくある間違い**: エクスポートする関数・クラスの戻り値型や引数型の明示的な型注釈を忘れがち

### Git操作の制限
- **コミット禁止**: ユーザーから明示的に指示された場合のみコミットを実行する
- **プッシュ禁止**: ユーザーから明示的に指示された場合のみプッシュを実行する
- **ブランチ操作制限**: ブランチの作成・切り替え・削除もユーザーの明示的な指示が必要
- **自動コミットの防止**: 変更を加えた後も、ユーザーの指示がない限りコミットしない

### 作業完了時の通知音
- ユーザーへの報告時は最後に音で通知
- 以下のコマンドを実行して通知する：

```shell
play /System/Library/Sounds/Frog.aiff vol 0.5
```

## プロジェクト固有の設定

### CIスクリプトの実行
- **CIコマンド**: `bun run ci` でフォーマット→型チェック→リント→ビルド→テスト→未使用コード検出を順次実行
- **エラー処理**: 途中でエラーが発生した場合は詳細を日本語で説明し、修正提案を行う
- **完了報告**: すべて成功時は音で通知し、結果を簡潔に報告
- **未使用コード検出**: CIで未使用の関数やクラスが検出されるため、実際に使用されるコードのみを実装すること

### プロジェクト固有の実装方針
- **後方互換性を持たせない**: 利用者が少ない今のうちに、破壊的変更を積極的に許容し、後方互換性を一切持たせない
  - APIの変更、関数名の変更、ディレクトリ構造の変更などを躊躇なく実施
  - 古いコードとの互換性維持のための冗長なコードは作らない
- **積極的なリファクタリング**: 綺麗なアーキテクチャを追求し、継続的にコードを改善
  - 不要なコード、重複したコード、複雑すぎるコードは即座に削除・簡潔化
  - より良い設計パターンが見つかれば、既存の実装を躊躇なく置き換える
- **依存関係の管理**: `bun run update:docs:deps-graph:all`で全ての依存図を更新しながらリファクタリング
  - 依存関係図は `docs/reports/dependencies/` ディレクトリに5種類のビューで出力される：
    - `layers.md` - レイヤー間の抽象的な関係（クリーンアーキテクチャの確認に最適）
    - `flow.md` - CLIエントリーポイントからの処理フロー（実行の流れを理解）
    - `prod.md` - プロダクションコードの完全な依存関係（詳細な構造把握）
    - `with-tests.md` - テストを含む全依存関係（テストカバレッジ確認）
    - `external.md` - 外部ライブラリへの依存（サードパーティ依存の監査）
  - リファクタリング前後で依存関係図を確認し、循環依存や不要な依存を排除
  - 各モジュールの責務を明確化し、単一責任の原則を徹底

### リファクタリング時の依存関係図活用ガイドライン
- **リファクタリング前の確認**: 
  - `bun run update:docs:deps-graph:all`を実行して最新の依存関係図を生成
  - 目的に応じて適切な図を選択：
    - アーキテクチャ変更時 → `layers.md`で層の境界を確認
    - 新機能追加時 → `flow.md`で処理の流れに組み込む場所を特定
    - 詳細なリファクタリング時 → `prod.md`で影響範囲を把握
- **高凝集・低結合の原則（クリーンコード）**:
  - **高凝集（High Cohesion）**: 関連性の高い機能を同一モジュールに集約
    - 明確な役割があれば、それに関連する機能はまとめる
    - 無理に分割して依存関係を複雑にしない
  - **低結合（Low Coupling）**: モジュール間の依存を最小限に
    - 必要最小限のインターフェースのみを公開
    - 直接的な依存よりも抽象化を通じた依存を推奨
- **問題の特定**:
  - 循環依存がないか確認（A→B→C→Aのような依存関係）
  - 不必要に多くのモジュールに依存していないか確認
  - 依存の方向が適切か（下位レイヤーが上位レイヤーに依存していないか）
- **リファクタリング中の活用**:
  - モジュール分割・統合時は、高凝集・低結合の観点で判断
  - 新しい依存を追加する前に、それが本当に必要か検証
  - リファクタリング後も再度図を生成し、改善を確認
- **理想的な依存構造**:
  - 上位レイヤー（cli, processor）から下位レイヤー（utils, types）への単方向の流れ
  - 各モジュールが明確な役割を持ち、その役割に必要な機能は適切に集約
  - モジュール間の依存は最小限で、インターフェースが明確

### エクスポート方針
- **最小限の公開API**: このプロジェクトは主にCLIツールとして提供される。npmパッケージとしての公開APIは最小限（CLIエントリーポイントのみ）とする
- **内部実装の非公開**: converters、handlers、utils等の内部モジュールは一切エクスポートしない
- **index.tsの役割**: `main`関数のみをエクスポートする最小限の公開インターフェース
- **後方互換性の不要性**: 内部実装の変更時に既存のエクスポートを残したり、非推奨警告を出したりする必要はない
- **リファクタリングの自由**: 公開APIが最小限のため、内部実装は自由にリファクタリング可能

### バージョン管理
- **バージョンソース**: `package.json` と `src/domain/version.ts` の2箇所でバージョンを管理
- **自動更新**: release-please または release-it によって両ファイルが自動更新される
- **整合性チェック**: `src/domain/version.test.ts` でバージョンの一致を自動テスト
- **注意点**: `src/domain/version.ts` は手動で編集しない（自動更新されるファイル）

### Requirements
- **Node.js**: v24 以上
- **bun**: 最新版
